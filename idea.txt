SKCalculus = {
    * : { x,y | z }
    S
    K
    ----
    I = *{x=*{x=S,y=K}.z,y=K}.z
    B = *{x=*{x=S,y=*{x=K,y=S}},y=K}
    C = *{x=*{x=S,y=*{x=*{x=B,y=B},y=S}},y=*{x=K,y=K}}
}

There seem to be three different uses of braces above.  The top level one,
named SKCalculus, is the definition of an object with three abstract
parameters.  The one after the colon in the abstract declaration of * is
a type or a pattern or something, something an incoming object must conform
to.  The one directly after the * is an application, filling in the abstract
parameters of an object.

LambdaCalculus = {
    ----
    * : { x,y | z }
    \ : { body : {x|z} | z }
}

LambdaSK = {
    L : LambdaCalculus
    ----
    SK = SKCalculus {
        * = L.*
        S = L.\{ body = { x | a = x, 
                              z = L.\{ body = { x | b = x,
                                                    z = L.\{ body = { x | c = x,
                                                                          z = *{x=*{x=a,y=c},y={x=b,y=c}}}}}}}}
        K = L.\{ body = { x | a = x,
                              z = L.\{ body = { x | z = a } }}}
    }
}


BL = BuiltinLambdaCalculus

BL.*{ x = LambdaSK { L = BL }.SK.I, y = 42 }  -- >  42

I am confused about LambdaCalculus above.  I want to be declaring a
type, a shorthand for a complex thing to go after the colon below.
Maybe I'm being confused by the syntax.  I want to make everything the
same because it's pretty, but maybe I am just confusing myself by
punning, and they aren't actually the same.

So, are types objects?  It would be System-F-tastic if we could say:

Dependent = { 
    A, B
    p : {| a : A, b : B }
    ----
    o = p.a
}

But we could still have two separate classifications for types and
objects.  If not, what does this mean:

Foo = {
    ----
    a : Integer,
    b = 42
}

It's kind of a combination type-object.  It's clear to me what it would
do if it appeared to the right of a colon -- be equivalent to {| a :
Integer }, but also allow a .b member that evaluates to 42.  Would it be
legal to pass an object in that parameter that set b to something else,
or is this a requirement that b be 42 (if present)?

However it seems illegal as a value, because what is Foo.a?  Maybe it
stays abstract, i.e. Foo.a evaluates to Foo.a.  By RT, it would evaluate
to.

    { | a : Integer, b = 42 }.a

And that's as much as you get.  But... that thing doesn't make any sense
to me.  You never get a chance to fill it in with anything, because it's
a direct object reference.  So I don't think that's it.

Perhaps we could still allow it to be a valid record object, and allow
you to get is b member but not its a member.  But what about:

Bar = {
    ----
    a : Integer,
    b = a + 1
}

Then you're back to the very same problem.  So nevermind on that.

So that means that types are distinct from objects?  What is a possible
type that {| x : Integer } would satisfy?  That means that you are
abstracting over things like it.  What would you like to know about
something like that?  Maybe that it has an x member but we don't know
what type it is?  That would be written:

Example = {
    T
    W = {| x:T }
    f : W
    ----
}

But that's not expressing a type of W, it's *defining* W.  What if we
wanted to take W as a parameter?

Example' = {
    W : {| x : Type }
    f : W
    ----
}

No, that implies that W is an object that has a member x which is a
type.  But that's not what it is.  W is a type that specifies a member
x.  Unless those are the same....

So what if we consider objects to be types.  We say

    { a = b, c = d } : { a = T, c = U }

means

    b : T, d : U

And then the above example of including definitions within a type is now
defunct.  Oh right, what about contravariance (parens added in c just to
emphasize dependence, not an actual example of syntax):

    { a | b = c(a) } : { a:T | b = U }

means

    for every a:T, c(a) : U

But that type is also an object O.  O{a = 42} = {| b = U }.  Maybe
that's right?  So:

    f : T

means

    every binding that is applicable to T is also applicable to f
    for all applicable bindings B, for all members y of T, f{B}.y : T{B}.y

So lambdas double as Î  types.  Huh.  That's weird.  Let's run with it.

So we have unified types and objects, in kind of a weird way.  So those
braces are not punned.  The final use of braces was as an application:

    *{x = S, y = K}.z

Where * : {x, y | z}.  This seems an obvious unification, just do
application f x, allowing the members of x to bind to the parameters of
f.  But what if x has parameters of its own?  Maybe they bubble out?

    *{w | x = w, y = K} = {w | z = *{x=w,y=K}}

Hmm, but if you meant that, why didn't you say that?  Maybe this is the
assumption tracking though.  It seems to beg that if there are unbound
assumptions in the lhs, they bubble up as well:

    *{w | x = w} = { w,y | z = *{x=w,y=y} }

What about member access:

    *{w | x = w}.z

I can't imagine any reasonable value for that.  The assumptions have
nowhere to bubble up to.  Which seems kind of like crappy assumption
tracking if it just errors out here.  But at least it errors out
statically, we know the type of *, so we know we didn't discharge all
the assumptions.  

So yeah, it's weird, but maybe it's worth a shot?
